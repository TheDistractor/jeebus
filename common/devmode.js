// Generated by CoffeeScript 1.6.3
(function() {
  var compileCoffeeScriptWithMap, compileIfNeeded, createWatcher, fatal, fs, main, moduleDir, parseSettings, path, pid, recompileGoFiles, runMain, settings, spawn, traverseDirs, watchDir;

  fs = require('fs');

  path = require('path');

  spawn = require('child_process').spawn;

  moduleDir = function(s) {
    return path.resolve('node_modules', s);
  };

  fatal = function(s) {
    console.error('\n[node] fatal error:', s);
    return process.exit(1);
  };

  main = void 0;

  pid = void 0;

  runMain = function() {
    var args, f, _i, _len, _ref;
    args = ['run'];
    _ref = fs.readdirSync('.');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      f = _ref[_i];
      if (/\.go$/i.test(f) && !/_test\./i.test(f)) {
        args.push(f);
        fs.watch(f, recompileGoFiles);
      }
    }
    args = args.concat(process.argv.slice(2));
    console.log('[node] go', args.join(' '));
    main = spawn('go', args, {
      stdio: ['ipc', process.stdout, process.stderr]
    });
    main.on('error', function(err) {
      return fatal('cannot launch "go"');
    });
    main.on('message', function(msg) {
      console.log('[node] pid message:', msg, '\n');
      return pid = msg | 0;
    });
    main.on('close', function(code) {
      if (code > 0) {
        return fatal('unexpected termination of "main", code: ' + code);
      }
    });
    return main.on('exit', function() {
      return fatal('main exited');
    });
  };

  recompileGoFiles = function() {
    if (pid > 0) {
      main.removeAllListeners();
      process.kill(pid, 'SIGHUP');
      pid = 0;
      return runMain();
    }
  };

  compileCoffeeScriptWithMap = function(sourceCode, filename) {
    var coffee, comment, compiled, convert;
    coffee = require(moduleDir('coffee-script'));
    compiled = coffee.compile(sourceCode, {
      filename: filename,
      sourceMap: true,
      inline: true,
      literate: path.extname(filename) !== '.coffee'
    });
    convert = require(moduleDir('convert-source-map'));
    comment = convert.fromJSON(compiled.v3SourceMap).setProperty('sources', [filename]).toComment();
    return "" + compiled.js + "\n" + comment + "\n";
  };

  compileIfNeeded = function(srcFile) {
    var destExt, destFile, destStat, err, jade, saveResult, src, srcExt, srcStat, stylus, t;
    if (/\.(coffee|coffee\.md|litcoffee|jade|styl)$/i.test(srcFile)) {
      srcExt = path.extname(srcFile);
      destExt = (function() {
        switch (srcExt) {
          case '.jade':
            return '.html';
          case '.styl':
            return '.css';
          default:
            return '.js';
        }
      })();
      destFile = srcFile.slice(0, -srcExt.length) + destExt;
      t = Date.now();
      saveResult = function(data) {
        var ms, n;
        n = data.length;
        ms = Date.now() - t;
        console.log("[node] compile " + srcFile + " -> " + destExt + " " + n + "b " + ms + " ms");
        return fs.writeFileSync(destFile, data);
      };
      try {
        srcStat = fs.statSync(srcFile);
        if (fs.existsSync(destFile)) {
          destStat = fs.statSync(destFile);
        }
        if (!((destStat != null ? destStat.mtime : void 0) >= srcStat.mtime)) {
          src = fs.readFileSync(srcFile, {
            encoding: 'utf8'
          });
          switch (srcExt) {
            case '.jade':
              jade = require(moduleDir('jade'));
              return saveResult(jade.compile(src, {
                filename: srcFile,
                pretty: true
              })());
            case '.styl':
              stylus = require(moduleDir('stylus'));
              return stylus.render(src, {
                filename: srcFile
              }, function(err, css) {
                if (err) {
                  return console.log('[node] stylus error', srcFile, err);
                } else {
                  return saveResult(css);
                }
              });
            default:
              return saveResult(compileCoffeeScriptWithMap(src, path.basename(srcFile)));
          }
        }
      } catch (_error) {
        err = _error;
        return console.log('[node] cannot compile', srcFile, err);
      }
    } else if (pid > 0) {
      if (/\.(html|js)$/i.test(srcFile)) {
        return main.send(true);
      } else if (/\.(css)$/i.test(srcFile)) {
        return main.send(false);
      } else if (/\.(go)$/i.test(srcFile)) {
        console.log("[node] changed", srcFile);
        return recompileGoFiles();
      }
    }
  };

  traverseDirs = function(dir, cb) {
    var f, stats, _i, _len, _ref, _results;
    stats = fs.statSync(dir);
    if (stats.isDirectory()) {
      cb(dir);
      _ref = fs.readdirSync(dir);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        _results.push(traverseDirs(path.join(dir, f), cb));
      }
      return _results;
    }
  };

  watchDir = function(root, cb) {
    return traverseDirs(root, function(dir) {
      return fs.watch(dir, function(event, filename) {
        var file;
        file = path.join(dir, filename);
        return cb(event, file);
      });
    });
  };

  createWatcher = function(root) {
    console.log(" ", root);
    traverseDirs(root, function(dir) {
      var f, _i, _len, _ref;
      _ref = fs.readdirSync(dir);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        compileIfNeeded(path.join(dir, f));
      }
      return fs.watch(dir, function(event, filename) {
        var file;
        file = path.join(dir, filename);
        if (fs.existsSync(file)) {
          return compileIfNeeded(file);
        } else {

        }
      });
    });
    return root;
  };

  parseSettings = function(fn) {
    var i, k, line, map, s, v, x, _i, _j, _len, _len1, _ref, _ref1;
    map = {};
    if (fs.existsSync(fn)) {
      _ref = fs.readFileSync(fn, 'utf8').split('\n');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        line = line.trim();
        i = line.indexOf('=');
        if (line[0] !== '#' && i > 0) {
          x = [];
          _ref1 = line.slice(0, i).trim().split('_');
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            s = _ref1[_j];
            x.push(s.slice(0, 1).toUpperCase() + s.slice(1).toLowerCase());
          }
          k = x.join("");
          v = line.slice(i + 1).trim();
          map[k] = JSON.parse(v);
        }
      }
    }
    return map;
  };

  console.log('[node] watching for file changes in:');

  settings = require(path.resolve(__dirname, '../setup')).settings;

  createWatcher((settings != null ? settings.appDir : void 0) || './app');

  createWatcher((settings != null ? settings.baseDir : void 0) || './base');

  createWatcher((settings != null ? settings.commonDir : void 0) || './common');

  createWatcher((settings != null ? settings.gadgetsDir : void 0) || './gadgets');

  runMain();

}).call(this);
