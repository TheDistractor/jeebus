// Generated by CoffeeScript 1.7.1
(function() {
  var ng,
    __slice = [].slice;

  ng = angular.module('myApp');

  console.log('NG', angular.version.full);

  ng.config(function($urlRouterProvider, $locationProvider) {
    $urlRouterProvider.otherwise('/');
    return $locationProvider.html5Mode(true);
  });

  ng.factory('jeebus', function($rootScope, $q) {
    var attach, connect, gadget, get, keys, processRpcReply, put, rpc, rpcPromises, send, seqNum, ws;
    ws = null;
    seqNum = 0;
    rpcPromises = {};
    processRpcReply = function() {
      var deferred, emitter, msg, n, reply, timer, _ref;
      n = arguments[0], msg = arguments[1], reply = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      _ref = rpcPromises[n], timer = _ref.timer, deferred = _ref.deferred, emitter = _ref.emitter;
      if (deferred) {
        clearTimeout(timer);
        if (msg === true) {
          rpcPromises[n].deferred = null;
          deferred.resolve(function(ee) {
            return rpcPromises[n].emitter = ee;
          });
          return;
        }
        if (msg === "" && reply.length) {
          deferred.resolve(reply[0]);
        } else if (msg && reply.length === 0) {
          console.error(msg);
          deferred.reject(msg);
        } else {
          console.error.apply(console, ["bad rpc reply", n, msg].concat(__slice.call(reply)));
        }
        return delete rpcPromises[n];
      } else if (emitter) {
        if (msg && reply.length) {
          return emitter.emit(msg, reply[0]);
        } else {
          delete rpcPromises[n];
          return emitter.emit('close', reply[0]);
        }
      } else {
        return console.error.apply(console, ["spurious rpc reply", n, msg].concat(__slice.call(reply)));
      }
    };
    connect = function(appTag) {
      var reconnect;
      reconnect = function(firstCall) {
        var wsProto;
        wsProto = ("https:" === document.location.protocol ? "wss://" : "ws://");
        ws = new WebSocket("" + wsProto + location.host + "/ws", [appTag]);
        ws.onopen = function() {
          console.log('WS Open');
          return $rootScope.$apply(function() {
            return $rootScope.$broadcast('ws-open');
          });
        };
        ws.onmessage = function(m) {
          if (m.data instanceof ArrayBuffer) {
            console.log('binary msg', m);
          }
          return $rootScope.$apply(function() {
            var data, e, _i, _len, _ref, _results;
            data = JSON.parse(m.data);
            switch (typeof data) {
              case 'object':
                if (Array.isArray(data)) {
                  return processRpcReply.apply(null, data);
                } else {
                  return console.log({
                    "spurious object received": m
                  });
                }
                break;
              case 'boolean':
                if (data) {
                  return window.location.reload(true);
                } else {
                  console.log("CSS Reload");
                  _ref = document.getElementsByTagName('link');
                  _results = [];
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    e = _ref[_i];
                    if (e.href && /stylesheet/i.test(e.rel)) {
                      _results.push(e.href = "" + (e.href.replace(/\?.*/, '')) + "?" + (Date.now()));
                    } else {
                      _results.push(void 0);
                    }
                  }
                  return _results;
                }
                break;
              default:
                return console.log('Server msg:', data);
            }
          });
        };
        return ws.onclose = function() {
          console.log('WS Lost');
          $rootScope.$apply(function() {
            return $rootScope.$broadcast('ws-lost');
          });
          return setTimeout(reconnect, 1000);
        };
      };
      return reconnect(true);
    };
    send = function(payload) {
      ws.send(angular.toJson(payload));
      return this;
    };
    keys = function(prefix) {
      return rpc('keys', prefix);
    };
    get = function(key) {
      return rpc('get', key);
    };
    put = function(key, value) {
      return send([0, 'put', key, value]);
    };
    rpc = function() {
      var args, cmd, d, n, t;
      cmd = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      d = $q.defer();
      n = ++seqNum;
      ws.send(angular.toJson([cmd, n].concat(__slice.call(args))));
      t = setTimeout(function() {
        console.error("RPC " + n + ": no reponse", args);
        delete rpcPromises[n];
        return $rootScope.$apply(function() {
          return d.reject();
        });
      }, 10000);
      rpcPromises[n] = {
        timer: t,
        deferred: d
      };
      return d.promise;
    };
    gadget = function() {
      var args, e;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      e = new EventEmitter;
      rpc.apply(null, args).then(function(eeSetter) {
        return eeSetter(e);
      });
      return e;
    };
    attach = function(table, rowHandler) {
      var g;
      g = gadget('Attach', {
        In: "/" + table + "/"
      });
      g.get = function(key) {
        return this.rows[this.keys[key]];
      };
      g.set = function(key, row) {
        var _base, _name;
        row.id = key;
        if ((_base = this.keys)[_name = row.id] == null) {
          _base[_name] = this.rows.length;
        }
        return this.rows[this.keys[row.id]] = row;
      };
      g.put = function(key, row) {
        this.set(key, row);
        return put("/" + table + "/" + key, row);
      };
      g.on('Out', function(m) {
        switch (m.Tag) {
          case '<range>':
            return this.emit('init', table);
          case '<sync>':
            return this.emit('sync', table);
          default:
            return this.emit('data', m.Tag.slice(2 + table.length), m.Msg);
        }
      });
      g.on('data', rowHandler != null ? rowHandler : g.set);
      g.rows = [];
      g.keys = {};
      return g;
    };
    return {
      connect: connect,
      send: send,
      keys: keys,
      get: get,
      put: put,
      rpc: rpc,
      gadget: gadget,
      attach: attach
    };
  });

}).call(this);
