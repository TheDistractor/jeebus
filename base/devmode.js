// Generated by CoffeeScript 1.7.1
(function() {
  var compileCoffeeScriptWithMap, compileIfNeeded, config, createWatcher, execFile, fatal, fs, main, moduleDir, npmExe, ok, packages, parseConfig, path, pid, recompileGoFiles, runMain, spawn, traverseDirs, watchDir, _ref,
    __slice = [].slice;

  fs = require('fs');

  path = require('path');

  _ref = require('child_process'), execFile = _ref.execFile, spawn = _ref.spawn;

  moduleDir = function(s) {
    return path.resolve('node_modules', s);
  };

  fatal = function(s) {
    console.error('\n[node] fatal error:', s);
    return process.exit(1);
  };

  main = void 0;

  pid = void 0;

  runMain = function() {
    var args, f, _i, _len, _ref1;
    args = ['run'];
    _ref1 = fs.readdirSync('.');
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      f = _ref1[_i];
      if (/\.go$/i.test(f) && !/_test\./i.test(f)) {
        args.push(f);
        fs.watch(f, recompileGoFiles);
      }
    }
    args = args.concat(process.argv.slice(2));
    console.log('[node] go', args.join(' '));
    main = spawn('go', args, {
      stdio: ['ipc', process.stdout, process.stderr]
    });
    main.on('error', function(err) {
      return fatal('cannot launch "go"');
    });
    main.on('message', function(msg) {
      console.log('[node] pid message:', msg, '\n');
      return pid = msg | 0;
    });
    main.on('close', function(code) {
      if (code > 0) {
        return fatal('unexpected termination of "main", code: ' + code);
      }
    });
    main.on('exit', function() {
      return fatal('main exited');
    });
    return main.send(null);
  };

  recompileGoFiles = function() {
    if (pid > 0) {
      main.removeAllListeners();
      process.kill(pid, 'SIGHUP');
      pid = 0;
      return runMain();
    }
  };

  compileCoffeeScriptWithMap = function(sourceCode, filename) {
    var coffee, comment, compiled, convert;
    coffee = require(moduleDir('coffee-script'));
    compiled = coffee.compile(sourceCode, {
      filename: filename,
      sourceMap: true,
      inline: true,
      literate: path.extname(filename) !== '.coffee'
    });
    convert = require(moduleDir('convert-source-map'));
    comment = convert.fromJSON(compiled.v3SourceMap).setProperty('sources', [filename]).toComment();
    return "" + compiled.js + "\n" + comment + "\n";
  };

  compileIfNeeded = function(srcFile) {
    var destExt, destFile, destStat, err, jade, saveResult, src, srcExt, srcStat, stylus, t;
    if (/\.(coffee|coffee\.md|litcoffee|jade|styl)$/i.test(srcFile)) {
      srcExt = path.extname(srcFile);
      destExt = (function() {
        switch (srcExt) {
          case '.jade':
            return '.html';
          case '.styl':
            return '.css';
          default:
            return '.js';
        }
      })();
      destFile = srcFile.slice(0, -srcExt.length) + destExt;
      t = Date.now();
      saveResult = function(data) {
        var ms, n;
        n = data.length;
        ms = Date.now() - t;
        console.log("[node] compile " + srcFile + " -> " + destExt + " " + n + "b " + ms + " ms");
        return fs.writeFileSync(destFile, data);
      };
      try {
        srcStat = fs.statSync(srcFile);
        if (fs.existsSync(destFile)) {
          destStat = fs.statSync(destFile);
        }
        if (!((destStat != null ? destStat.mtime : void 0) >= srcStat.mtime)) {
          src = fs.readFileSync(srcFile, {
            encoding: 'utf8'
          });
          switch (srcExt) {
            case '.jade':
              jade = require(moduleDir('jade'));
              return saveResult(jade.compile(src, {
                filename: srcFile,
                pretty: true
              })());
            case '.styl':
              stylus = require(moduleDir('stylus'));
              return stylus.render(src, {
                filename: srcFile
              }, function(err, css) {
                if (err) {
                  return console.log('[node] stylus error', srcFile, err);
                } else {
                  return saveResult(css);
                }
              });
            default:
              return saveResult(compileCoffeeScriptWithMap(src, path.basename(srcFile)));
          }
        }
      } catch (_error) {
        err = _error;
        return console.log('[node] cannot compile', srcFile, err);
      }
    } else if (pid > 0) {
      if (/\.(html|js)$/i.test(srcFile)) {
        return main.send(true);
      } else if (/\.(css)$/i.test(srcFile)) {
        return main.send(false);
      } else if (/\.(go)$/i.test(srcFile)) {
        console.log('[node] changed', srcFile);
        return recompileGoFiles();
      }
    }
  };

  traverseDirs = function(dir, cb) {
    var f, stats, _i, _len, _ref1, _results;
    stats = fs.statSync(dir);
    if (stats.isDirectory()) {
      cb(dir);
      _ref1 = fs.readdirSync(dir);
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        f = _ref1[_i];
        _results.push(traverseDirs(path.join(dir, f), cb));
      }
      return _results;
    }
  };

  watchDir = function(root, cb) {
    return traverseDirs(root, function(dir) {
      return fs.watch(dir, function(event, filename) {
        var file;
        file = path.join(dir, filename);
        return cb(event, file);
      });
    });
  };

  createWatcher = function(root) {
    if (fs.existsSync(root)) {
      console.log(' ', root);
      return traverseDirs(root, function(dir) {
        var f, _i, _len, _ref1;
        _ref1 = fs.readdirSync(dir);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          f = _ref1[_i];
          compileIfNeeded(path.join(dir, f));
        }
        return fs.watch(dir, function(event, filename) {
          var file;
          file = path.join(dir, filename);
          if (fs.existsSync(file)) {
            return compileIfNeeded(file);
          } else {

          }
        });
      });
    }
  };

  parseConfig = function(fn) {
    var i, k, line, map, v, _i, _len, _ref1;
    map = {};
    if (fs.existsSync(fn)) {
      _ref1 = fs.readFileSync(fn, 'utf8').split('\n');
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        line = _ref1[_i];
        i = line.indexOf('=');
        if (i > 0 && line.trim()[0] !== '#') {
          k = line.slice(0, i).trim();
          v = line.slice(i + 1).trim();
          map[k] = v;
        }
      }
    }
    return map;
  };

  console.log('[node] watching for file changes in:');

  config = parseConfig('./config.txt');

  createWatcher(process.env.APP_DIR || config.APP_DIR || './app');

  createWatcher(process.env.BASE_DIR || config.BASE_DIR || './base');

  createWatcher(process.env.GADGETS_DIR || config.GADGETS_DIR || './gadgets');

  try {
    ok = require('convert-source-map');
  } catch (_error) {}

  if (ok) {
    runMain();
  } else {
    packages = ['coffee-script', 'convert-source-map', 'jade', 'stylus'];
    console.log('[node] installing npm packages:', packages.join(', '));
    npmExe = process.platform === 'win32' ? 'npm.cmd' : 'npm';
    execFile(npmExe, ['install'].concat(__slice.call(packages)), {
      env: process.env
    }, function(err, o, e) {
      if (err != null) {
        fatal(err);
      }
      return runMain();
    });
  }

}).call(this);
