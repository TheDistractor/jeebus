// Convenience package to wrap all the gadgets available in JeeBus.
package jeebus

import (
	"flag"
	"fmt"
	"sort"
	"strings"

	"github.com/jcw/flow"
	_ "github.com/jcw/flow/gadgets"

	_ "github.com/jcw/jeebus/gadgets/database"
	_ "github.com/jcw/jeebus/gadgets/decoders"
	_ "github.com/jcw/jeebus/gadgets/fbpparse"
	_ "github.com/jcw/jeebus/gadgets/javascript"
	_ "github.com/jcw/jeebus/gadgets/network"
	_ "github.com/jcw/jeebus/gadgets/rfdata"
	_ "github.com/jcw/jeebus/gadgets/serial"
)

var Version = "0.9.0"

var Help = map[string]string{}

func init() {
	// Waiter can be defined in terms of other gadgets, but where to put this?
	flow.Registry["Waiter"] = func() flow.Circuitry {
		c := flow.NewCircuit()
		c.Add("s", "Sink")
		c.Add("c", "Concat3")
		c.Connect("s.Out", "c.In1", 0)
		c.Label("Gate", "s.In")
		c.Label("In", "c.In2")
		c.Label("Out", "c.Out")
		return c
	}
	// Attach returns items from a database range and follows up with updates.
	flow.Registry["Attach"] = func() flow.Circuitry {
		c := flow.NewCircuit()
		c.Add("fan", "FanOut")
		c.Add("sub", "MQTTSub")
		c.Add("tag", "AddTag")
		c.Add("db", "LevelDB")
		c.Add("cat", "Concat3")
		c.Connect("fan.Out:sub", "sub.Topic", 0)
		c.Connect("fan.Out:tag", "tag.In", 0)
		c.Connect("tag.Out", "db.In", 0)
		c.Connect("db.Out", "cat.In1", 0)
		c.Connect("sub.Out", "cat.In2", 100) // with buffering
		c.Feed("tag.Tag", "<range>")
		c.Label("In", "fan.In")
		c.Label("Out", "cat.Out")
		return c
	}

	flow.Registry["help"] = func() flow.Circuitry { return &helpCmd{} }
	Help["help"] = `Show this help text with a list of commands.`

	flow.Registry["info"] = func() flow.Circuitry { return &infoCmd{} }
	Help["info"] = `Show the list of registered gadgets and circuits.`

	// database
	Help["dbdump"] = `Dump (part of) the contents of the database to stdout.`
	Help["dbexport"] = `Export (part of) the database as JSON to stdout.`
	Help["dbimport"] = `Import a JSON file, as generated by "export".`
	Help["dbget"] = `Get one entry from the database.`
	Help["dbput"] = `Store or delete an entry in the database.`
	Help["dbkeys"] = `List the set of (sub-) keys in the database.`
	// network
	Help["mqttpub"] = `Publish a message on a topic using MQTT.`
	Help["mqttsub"] = `Subscribe to one or more topics using MQTT.`
}

type helpCmd struct{ flow.Gadget }

func (g *helpCmd) Run() {
	if info, ok := Help[flag.Arg(1)]; ok {
		s := strings.SplitN(strings.TrimSpace(info), "\n", 2)
		if len(s) > 1 {
			info = s[0] + "\n\n" + s[1] + "\n"
		}
		fmt.Print(info, "\n")
		return
	}

	cmds := []string{}
	max := 0
	for name, _ := range Help {
		cmds = append(cmds, name)
		if len(name) > max {
			max = len(name)
		}
	}
	sort.Strings(cmds)
	fmt.Println("List of additional commands:\n")
	for _, name := range cmds {
		info := Help[name]
		fmt.Printf("  %-*s  %s\n", max, name, strings.SplitN(info, "\n", 2)[0])
	}
	fmt.Println("\nUse 'help <cmd>' for more information or '-h' for debug options.")
}

// This example illustrates how to define a new gadget. It has no input or
// output ports, is registered using a lowercase name, and has a help entry.
// This is only useful from the command line, i.e. "housemon info".

type infoCmd struct{ flow.Gadget }

func (g *infoCmd) Run() {
	fmt.Println("Registered gadgets and circuits:\n")
	flow.PrintRegistry()
	fmt.Println()
}
